########### Jinja2 Macro for Proxy Servers ###############
{% macro server_block(name, healthcheck='', healthcheck_uri='', external_domain_name='', internal_domain_name='', protocol='https') -%}
server {
    listen              80;
    listen              443 ssl http2;
    server_name  {{ name }}{% if external_domain_name != None %}.{{ external_domain_name }}{% endif %};

    {% if ssl_directives is defined -%}
        {% for key, ssl_directive in ssl_directives.iteritems()  -%}
            {{ key }} {{ ssl_directive }};
        {% endfor -%}
    {% else %}
        ssl_certificate      /etc/ssl/nginx/certificate.pem;
        ssl_certificate_key  /etc/ssl/nginx/key.pem;
    {% endif -%}

    include		nginx-ssl.conf;
    rewrite_log on;
    
    keepalive_timeout	3600s;
    keepalive_disable	none;
    keepalive_requests  100000;


    location / {
        proxy_pass {{ protocol }}://{{ name }};
        proxy_set_header Host {{ name }}{% if internal_domain_name != None %}.{{ internal_domain_name }}{% endif %};

        proxy_ssl_session_reuse 	on;
        proxy_ssl_protocols         TLSv1.2;
        #proxy_ssl_ciphers           'ECDHE-RSA-AES128-GCM-SHA256';
        proxy_ssl_verify 			off;
        proxy_read_timeout     		3600;
        proxy_connect_timeout  		3600;

        # Default is HTTP/1, keepalive is only enabled in HTTP/1.1
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Accept-Encoding "";
    }


}
{%- endmacro %}


{% if log_to_syslog %}
error_log {{ syslog_error_log_location }};
{% else %}
error_log {{ error_log_location }};
{% endif %}
worker_processes  auto;

events {
  worker_connections  1024;
}

daemon off;

http {

    include mime.types;
    include nginx-gz.conf;

    resolver {{ resolver.host }} valid={{ resolver.ttl }};  #use local DNS and override TTL to whatever value makes sense
    resolver_timeout 10s;
    client_max_body_size 30M;

    {% if log_to_syslog %}
        log_format json '{"service_name": "{{ service_log_name }}",'
             '"time": "$time_iso8601", '
             '"remote_addr": "$remote_addr", '
             '"remote_user": "$remote_user", '
             '"body_bytes_sent": $body_bytes_sent, '
             '"request_time": $request_time, '
             '"status": $status, '
             '"request": "$request", '
             '"request_method": "$request_method", '
             '"http_referrer": "$http_referer", '
             '"http_x_forwarded_for": "$http_x_forwarded_for", '
             '"http_user_agent": "$http_user_agent"}';
    {% else %}
        log_format main {{ service_log_name }} '$remote_addr - $remote_user [$time_local] "$request" '
              '$status $body_bytes_sent "$http_referer" '
              '"$http_user_agent" "$http_x_forwarded_for"';
    {% endif %}

    {% if log_to_syslog %}
        access_log {{ syslog_access_log_location }};
    {% else %}
        access_log {{ access_log_location }};
    {% endif %}
    
    proxy_cache_path /usr/src/app/cache levels=1:2 keys_zone=oauth_cache:10m max_size=10m inactive=15s use_temp_path=off;

    #DDOS Configs
    limit_req_zone $binary_remote_addr zone=ddosrequests:25m rate=100r/s;
    limit_conn_zone $binary_remote_addr zone=ddosconnections:25m;

    {% for name, service in services.iteritems() %}
    upstream {{ name }} {
        server        {{ service.server }};
        zone backend  64k;
        keepalive 		300;
    }
    {% endfor %}

    server {
        listen 80;

        location /v1/users {
			proxy_cache oauth_cache;
			#proxy_cache_min_uses 3;
			proxy_cache_valid      200  30s;
			proxy_cache_use_stale  error timeout invalid_header updating http_500 http_502 http_503 http_504;
            proxy_pass https://user-manager;
            proxy_set_header Host user-manager{% if internal_domain_name != None and internal_domain_name != '' %}.{{ internal_domain_name }}{% endif %};

            proxy_ssl_session_reuse 	on;
			proxy_ssl_protocols         TLSv1.2;
			#proxy_ssl_ciphers           'ECDHE-RSA-AES128-GCM-SHA256';
			proxy_ssl_verify 			off;
			proxy_read_timeout     		3600;
 			proxy_connect_timeout  		3600;

			# Default is HTTP/1, keepalive is only enabled in HTTP/1.1
			proxy_http_version 1.1;
			proxy_set_header Connection "";
			proxy_set_header Accept-Encoding "";
			#allow 173.186.135.1/24;
			#allow 127.0.0.1;
    		#deny  all;
	    }

        location / {
            return         301 https://$host$request_uri;
        }
    }

    server {
        listen       443 ssl http2	default_server;

        {% if ssl_directives is defined -%}
            {% for key, ssl_directive in ssl_directives.iteritems()  -%}
                {{ key }} {{ ssl_directive }};
            {% endfor -%}
        {% else %}
            ssl_certificate      /etc/ssl/nginx/certificate.pem;
            ssl_certificate_key  /etc/ssl/nginx/key.pem;
        {% endif -%}
        include nginx-ssl.conf;

        keepalive_timeout	3600s;
        keepalive_disable	none;
        keepalive_requests  100000;

        server_name {{ name }};

        {% if root %}
            root {{ root }};
        {% endif %}

        include default-location.conf;

			#DDOS Configs
			limit_req zone=ddosrequests burst=150 nodelay;
            #should only be used when under attack.
            #limit_conn ddosconnections 100;
            #set non-default response code to indicate no response and closed connection
            limit_req_status 444;


        location = /status.html {
            root /usr/share/nginx/html/;
        }
    }
    
    {% for name, service in services.iteritems() if service.server_block%}
            {{ server_block(name, service.healthcheck, service.healthcheck_uri, external_domain_name=external_domain_name, internal_domain_name=internal_domain_name, protocol=service.protocol) }}
    {% endfor %}
}

stream{
    upstream content-db {
        server        content-db{% if internal_domain_name != None and internal_domain_name != '' %}.{{ internal_domain_name }}{% endif %}:28015;
        zone stream  64k;
    }

    resolver {{ resolver.host }} valid={{ resolver.ttl }};  #use local DNS and override TTL to whatever value makes sense
    resolver_timeout 10s;

    server {
        listen              28015;
        proxy_connect_timeout 1s;
        proxy_timeout 3s;
        proxy_pass content-db;
    }
}
